# 一种分布式IM服务架构设计

## 概述

### 可扩展性

衡量一个应用服务好坏的因素之一是可扩展性。扩展可分为垂直扩展（升级到更强大的机器）和水平扩展（将负载分配到多个机器）。但是机器性能不可能无限制地增长，可扩展性大多数时候描述的还是水平扩展。

我们可以将服务分为无状态服务和有状态服务。大多数Web服务都是无状态服务，客户端向服务器发送HTTP请求，服务器处理请求进行一些操作比如访问数据库等，然后返回响应。服务器一般不会“永久”储存客户端或者用户的信息。对于这样的无状态服务，水平扩展很容易，只需要部署在更多的服务器上即可。

但是IM服务以及比如游戏服务器等属于有状态服务。以群聊为例，客户端发送消息到服务器，服务器需要获取对应的群信息，然后查看在线状态执行转发、持久化等操作。如果非要做成无状态服务，那么用户每发一条消息服务器就得访问多次数据库，且在分布式且使用TCP通信的情况下，当前服务器不可能持有所有客户端的长连接，势必要和其他所有服务器进行通信，这是不能接受的。

分片（Sharding）是一种直观且常用的用于水平扩展的方式。其思想很简单：根据某些（元）信息将数据区分开来，并使用某种方式（哈希）映射到相应的机器上。使得数据/请求可以被分散到不同服务器上进行处理。

因此我们可以对所有客户端进行分片，还可以对所有群组进行分片。以下是总体架构的示意图：

![](http://cdn.lsongzhi.cn/img/im.png)

`Connector`与客户端连接，负责客户端消息的接受和推送以及保证可靠到达。`Chatter`负责群聊，为简便起见，我们可以将私聊也视为群聊。而中间的`Router`就是实现分片的关键组件。`Connector`集群对用户进行分片，根据用户ID把单个用户的请求分配给一个客户端。`Chatter`对群组进行分片。它们之间通过RPC进行通信。

如此一来，当客户端登录或重连时，它会连接到对应的`Connector`，客户端发送消息到`Connector`，`Connector`再经由`Router`转发到对应的`Chatter`，然后`Chatter`再经由`Router`转发给对应的`Connector`，最后到达其他客户端。

### 可靠性

但是可扩展性不是唯一要考虑的因素，可靠性同样重要。对于IM服务这样的有状态服务，我们通常要考虑以下几点：

* 服务器故障了怎么办，怎么保证服务器故障之前的状态不会丢失；
* 怎么保证断线后重连的服务器与接手其请求的服务器之间不发生冲突；

因此我们就要重新考量“有状态服务”中的“有状态”是什么意思。无状态服务的流程通常是接收请求，增删改查可以将数据持久化的数据库等组件，然后返回响应。有状态服务的流程类似，但是很多数据（状态）是直接保存在内存中的，不需要查询数据库，这极大的减少了响应延迟。但是与此同时，当服务器故障，这些状态也就丢失了。因此我们至少要将一部分关键的状态进行持久化，这样当服务器故障之后也可以从数据库恢复且不违反数据一致性。那么，这种“有状态服务”中的“状态”其实也可以看作某种层面上的缓存，有状态服务和无状态服务之间的界限也就变得模糊。

我们还要保证断线后重连的服务器与接收其请求的服务器之间不会发生冲突。因为在分布式系统中，服务器本身故障和只是网络延迟或中断之间是很难区分的，因此只能统统假设为服务器故障。当一个`Chatter`故障，`Router`就会将本来要发送给它的消息发送给其他`Chatter`，同时修改其内部数据，将请求永久性地重定向到新的`Chatter`。当服务器重连之后，即使其还保存有群组状态，但是这时已经没有新的请求发送给它，经过一段时间后，该群组状态会被自动清除。

## 消息无重复有序可靠到达

将消息分成两种，一种是群组消息，一种是用户消息。群组消息的消息序列号由不同群组单独生成，这可以保证单独同一群组下所有消息的唯一有序递增。具体实现方式可以参考美团的分布式ID生成方案中的号段模式，服务器在加载群组服务消息时，申请一个号段，之后即在内存中分配ID，用完号段之后再向数据库申请。这样可以保证服务器故障也不影响ID的唯一有序递增。但是这种方案不能保证ID连续。用户消息的序列号生成同理。

消息去重可以通过客户端本地生成去重ID，再在服务器和其他客户端进行缓存然后判断可以实现。

这里放松对可靠到达的要求，在消息发送方看来，只要消息持久化到数据库就算消息发送成功。这样就不用考虑用户在线离线以及群聊转发的情况。

## 消息存储模型及消息同步

对于群聊来说，消息存储由两种模型：存多份/存一份。存多份是指每个用户拥有一个自己的消息队列，存储着其接受到的所有群聊的消息。这种模型的优点是读取和同步时方便快捷，缺点是需要存多份消息且服务器处理负担也会加重。存一份是指每个群组存储其所有消息，同时保存用户最近读取的消息ID，客户端读取时再拉取相应消息。这样的优点是减少存储量以及处理负担，缺点是客户端在同步时需要拉取用户所有群组的消息来查看是否有未读消息。

这里将二者结合，基于存一份的模型，同时尽量减少同步时的开销。额外维护一个用户当前所有会话的列表及相应信息（最近读取消息ID等），这样在客户端登录或同步时，直接拉取这个列表，不用遍历所有群聊。因为我们可以保证同一时间客户端只会连接到一个`Connector`，所以我们可以放在`Connector`的内存中，而这个列表也是可以根据数据库中数据构建出来的，所以不用担心状态丢失。消息到达`Connector`时，其更改内存中维护的相应信息，并维护一个消息推送队列以保证可靠到达。这样，我们还可以实现客户端的快速重连，因为重连时需要同步的消息都保存在`Connector`的内存中，不用去数据库中拉取。

用户消息则存储为单独的队列。

